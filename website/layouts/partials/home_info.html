{{- with site.Params.homeInfoParams }}
<article class="first-entry home-info">
    <header class="entry-header">
        <h1>{{ .Title | markdownify }}</h1>
    </header>
    <div class="entry-content">
        {{ .Content | markdownify }}
    </div>

    <!-- ğŸ“ ç¾åœ¨åœ°ã‹ã‚‰æ¢ã™ãƒœã‚¿ãƒ³ -->
    <div style="margin-top: 24px; margin-bottom: 24px; text-align: center;">
        <button id="btn-near-me" style="
            background-color: #e60012; 
            color: white; 
            border: none; 
            padding: 14px 28px; 
            font-size: 16px; 
            border-radius: 50px; 
            cursor: pointer; 
            font-weight: bold; 
            box-shadow: 0 4px 6px rgba(0,0,0,0.15); 
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        ">
            <span>ğŸ“</span> ç¾åœ¨åœ°ã‹ã‚‰æ¢ã™
        </button>
        <p id="near-me-status" style="font-size: 13px; color: #666; margin-top: 10px; min-height: 1.2em;"></p>
    </div>

    <footer class="entry-footer">
        {{ partial "social_icons.html" (dict "align" site.Params.homeInfoParams.AlignSocialIconsTo) }}
    </footer>
</article>

<script>
    document.getElementById('btn-near-me').addEventListener('click', function () {
        const status = document.getElementById('near-me-status');
        const btn = document.getElementById('btn-near-me');

        if (!navigator.geolocation) {
            status.textContent = "ãŠä½¿ã„ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯ä½ç½®æƒ…å ±ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“ã€‚";
            return;
        }

        status.textContent = "ä½ç½®æƒ…å ±ã‚’å–å¾—ä¸­...";
        btn.disabled = true;
        btn.style.opacity = "0.7";
        btn.style.cursor = "wait";

        navigator.geolocation.getCurrentPosition(success, error, {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 0
        });

        function success(position) {
            const userLat = position.coords.latitude;
            const userLon = position.coords.longitude;

            status.textContent = "è¿‘ãã®é§…ã‚’æ¢ã—ã¦ã„ã¾ã™...";

            // JSONãƒ‡ãƒ¼ã‚¿å–å¾—ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥å›é¿ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ä»˜ãï¼‰
            fetch('/stations_geo.json?' + new Date().getTime())
                .then(response => {
                    if (!response.ok) throw new Error("Network response was not ok");
                    return response.json();
                })
                .then(stations => {
                    if (!stations || stations.length === 0) {
                        status.textContent = "é§…ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚";
                        resetBtn();
                        return;
                    }

                    let closest = null;
                    let minDist = Infinity;

                    stations.forEach(station => {
                        const d = getDistanceFromLatLonInKm(userLat, userLon, station.lat, station.lon);
                        // 100kmä»¥å†…ã®ã¿å¯¾è±¡ï¼ˆé ã™ãã‚‹å ´æ‰€ã‚’é™¤å¤–ï¼‰
                        if (d < 100 && d < minDist) {
                            minDist = d;
                            closest = station;
                        }
                    });

                    if (closest) {
                        const distDisplay = minDist < 1 ? Math.round(minDist * 1000) + "m" : Math.round(minDist * 10) / 10 + "km";
                        status.textContent = `${closest.name}é§…ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸï¼ˆç´„${distDisplay}ï¼‰...ç§»å‹•ã—ã¾ã™`;

                        // å°‘ã—ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«çµæœã‚’è¦‹ã›ã¦ã‹ã‚‰é·ç§»
                        setTimeout(() => {
                            window.location.href = closest.url;
                        }, 500);
                    } else {
                        status.textContent = "è¿‘ãï¼ˆ100kmåœå†…ï¼‰ã«åˆ©ç”¨å¯èƒ½ãªåº—èˆ—ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚";
                        resetBtn();
                    }
                })
                .catch(err => {
                    console.error(err);
                    status.textContent = "ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚";
                    resetBtn();
                });
        }

        function error(err) {
            console.warn(`ERROR(${err.code}): ${err.message}`);
            switch (err.code) {
                case err.PERMISSION_DENIED:
                    status.textContent = "ä½ç½®æƒ…å ±ã®åˆ©ç”¨ãŒè¨±å¯ã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚";
                    break;
                case err.POSITION_UNAVAILABLE:
                    status.textContent = "ä½ç½®æƒ…å ±ã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚";
                    break;
                case err.TIMEOUT:
                    status.textContent = "ä½ç½®æƒ…å ±ã®å–å¾—ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚";
                    break;
                default:
                    status.textContent = "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚(" + err.message + ")";
            }
            resetBtn();
        }

        function resetBtn() {
            btn.disabled = false;
            btn.style.opacity = "1";
            btn.style.cursor = "pointer";
        }

        // Haversine formula
        function getDistanceFromLatLonInKm(lat1, lon1, lat2, lon2) {
            var R = 6371; // Radius of the earth in km
            var dLat = deg2rad(lat2 - lat1);
            var dLon = deg2rad(lon2 - lon1);
            var a =
                Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2)
                ;
            var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            var d = R * c; // Distance in km
            return d;
        }

        function deg2rad(deg) {
            return deg * (Math.PI / 180)
        }
    });
</script>
{{- end -}}